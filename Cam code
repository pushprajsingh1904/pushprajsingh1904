/* ============================================================
   ESP32-CAM streaming + turret control
   CAM static IP: 192.168.4.2 (on Rover_AP)
   ============================================================ */

#include "esp_camera.h"
#include <WiFi.h>
#include <WebServer.h>
#include <ESP32Servo.h>
#include "esp_timer.h"
#include "img_converters.h"
#include "fb_gfx.h"
#include "fd_forward.h"

// ---------- WiFi (connect to Rover AP) ----------
const char* ssid = "Rover_AP";
const char* password = "12345678";

// static IP for cam on Rover AP
IPAddress static_ip(192,168,4,2);
IPAddress gateway(192,168,4,1);
IPAddress subnet(255,255,255,0);

// ---------- Camera pins for AI-Thinker (most modules) ----------
#define PWDN_GPIO_NUM     -1
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

WebServer server(80);

// ---------- Servos ----------
Servo yawServo;   // continuous
Servo pitchServo; // 0-90

#define YAW_PIN 12   // adjust if needed
#define PITCH_PIN 13 // adjust if needed

bool autoCam = false;
bool yawMoving = false;
int pitchPos = 45; // initial

// ---------- Camera server (MJPEG stream) ----------
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";

esp_err_t initCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  if(psramFound()){
    config.frame_size = FRAMESIZE_VGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_CIF;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  return esp_camera_init(&config);
}

void handleStream(){
  WiFiClient client = server.client();
  String response = String("HTTP/1.1 200 OK\r\n")
    + "Content-Type: " + String(STREAM_CONTENT_TYPE) + "\r\n"
    + "Access-Control-Allow-Origin: *\r\n\r\n";
  server.sendContent(response);

  while(true){
    camera_fb_t * fb = esp_camera_fb_get();
    if(!fb){ Serial.println("Camera capture failed"); return; }
    String head = String("--frame\r\nContent-Type: image/jpeg\r\nContent-Length: ") + fb->len + "\r\n\r\n";
    server.sendContent(head);
    server.client().write(fb->buf, fb->len);
    server.sendContent("\r\n");
    esp_camera_fb_return(fb);
    // break loop if client disconnected
    if(!server.client().connected()) break;
    delay(30); // ~30ms between frames
  }
}

// ---------- Turret handlers ----------
void handleYawLeft(){ yawServo.write(0); yawMoving=true; server.send(200,"text/plain","OK"); }
void handleYawRight(){ yawServo.write(180); yawMoving=true; server.send(200,"text/plain","OK"); }
void handleYawStop(){ yawServo.write(90); yawMoving=false; server.send(200,"text/plain","OK"); }

void handlePitchUp(){ pitchPos += 5; if(pitchPos>90) pitchPos=90; pitchServo.write(pitchPos); server.send(200,"text/plain","OK"); }
void handlePitchDown(){ pitchPos -= 5; if(pitchPos<0) pitchPos=0; pitchServo.write(pitchPos); server.send(200,"text/plain","OK"); }
void handlePitchStop(){ server.send(200,"text/plain","OK"); }

void handleAutoCamToggle(){ autoCam = !autoCam; server.send(200,"text/plain", autoCam?"ON":"OFF"); }
void handleAutoCamStatus(){ server.send(200,"text/plain", autoCam?"ON":"OFF"); }

// minimal root
void handleRootCam(){ server.send(200,"text/html","ESP32-CAM turret ready"); }

// ---------- setup & loop ----------
void setup(){
  Serial.begin(115200);
  // configure STA with static IP to connect to Rover AP
  WiFi.config(static_ip, gateway, subnet);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to Rover AP");
  int tries=0;
  while(WiFi.status()!=WL_CONNECTED && tries<40){
    delay(250); Serial.print(".");
    tries++;
  }
  if(WiFi.status()==WL_CONNECTED) {
    Serial.println("\nCAM IP: " + WiFi.localIP().toString());
  } else {
    Serial.println("\nFailed to connect to AP - will still start server on default STA IP");
  }

  // init camera
  if(initCamera() != ESP_OK){
    Serial.println("Camera init failed");
    while(true);
  }

  // servos
  yawServo.attach(YAW_PIN);
  pitchServo.attach(PITCH_PIN);
  yawServo.write(90); // stop
  pitchServo.write(pitchPos);

  // server routes
  server.on("/", handleRootCam);
  server.on("/stream", HTTP_GET, handleStream);
  server.on("/yawLeft", handleYawLeft);
  server.on("/yawRight", handleYawRight);
  server.on("/yawStop", handleYawStop);
  server.on("/pitchUp", handlePitchUp);
  server.on("/pitchDown", handlePitchDown);
  server.on("/pitchStop", handlePitchStop);
  server.on("/autoCam", handleAutoCamToggle);
  server.on("/autoCamStatus", handleAutoCamStatus);

  server.begin();
  Serial.println("CAM server started");
}

unsigned long lastAutoMove = 0;
int autoYawDir = 1;
void loop(){
  server.handleClient();

  // auto scan logic
  if(autoCam && millis()-lastAutoMove > 150){
    lastAutoMove = millis();
    // simple slow rotation: toggle yaw servo briefly
    if(autoYawDir>0) { yawServo.write(0); }
    else { yawServo.write(180); }
    // small pitch oscillation
    pitchPos += (autoYawDir)*3;
    if(pitchPos > 60){ pitchPos = 60; autoYawDir = -1; }
    if(pitchPos < 0){ pitchPos = 0; autoYawDir = 1; }
    pitchServo.write(pitchPos);
    // stop yaw after brief movement to simulate slow continuous
    delay(80);
    yawServo.write(90);
  }
}
