/* ============================================================
   ESP32 38-Pin Rover – Safe Pin Version  (All boot pins removed)
   Features:
     • Manual & Auto drive
     • Battery % + voltage display
     • 3 metal-detector inputs
     • Neo-6M GPS with map link
     • Ultrasonic obstacle detection
   ============================================================ */

#include <WiFi.h>
#include <WebServer.h>
#include <ESP32Servo.h>
#include <TinyGPSPlus.h>
#include <HardwareSerial.h>

// ---------------- WIFI SETUP -----------------
const char* ssid = "Rover_AP";
const char* password = "12345678";
WebServer server(80);

// -------------- MOTOR PINS -------------------
// (4 modules × 2 motors = 8 channels)
#define M1A 4
#define M1B 5
#define M2A 16
#define M2B 17
#define M3A 18
#define M3B 19
#define M4A 21
#define M4B 22
#define M5A 23
#define M5B 25
#define M6A 26
#define M6B 27
#define M7A 32
#define M7B 33
// M8 uses remaining safe pair
#define M8A 22
#define M8B 23

// -------------- SERVO -------------------------
Servo bootServo;
#define SERVO_PIN 13

// -------------- ULTRASONIC --------------------
#define TRIG_PIN 14
#define ECHO_PIN 34

// -------------- BATTERY SENSOR ---------------
#define BATTERY_PIN 35
#define V_DIV_RATIO 10.0  // adjust after calibration
#define BATTERY_FULL 12.6
#define BATTERY_EMPTY 10.5

// -------------- METAL DETECTORS --------------
#define DET1 36
#define DET2 38
#define DET3 39

// -------------- GPS --------------------------
HardwareSerial gpsSerial(1);
#define GPS_RX 4    // GPS TX -> ESP32 RX (GPIO4)
#define GPS_BAUD 9600
TinyGPSPlus gps;

// -------------- VARIABLES --------------------
bool autoMode = false;
String mineLog = "";
unsigned long lastMove = 0;

// =====================================================
// Helper functions
// =====================================================
float readBattery() {
  int adc = analogRead(BATTERY_PIN);
  float v = (adc / 4095.0) * 3.3 * V_DIV_RATIO;
  return v;
}

int batteryPercent(float v) {
  if (v >= BATTERY_FULL) return 100;
  if (v <= BATTERY_EMPTY) return 0;
  return (int)((v - BATTERY_EMPTY) / (BATTERY_FULL - BATTERY_EMPTY) * 100);
}

long readDistance() {
  digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  long dist = duration * 0.034 / 2;
  return dist;
}

void stopAll() {
  int motors[] = {M1A,M1B,M2A,M2B,M3A,M3B,M4A,M4B,M5A,M5B,M6A,M6B,M7A,M7B};
  for (int i = 0; i < 14; i++) digitalWrite(motors[i], LOW);
}

void forward() {
  digitalWrite(M1A, HIGH); digitalWrite(M1B, LOW);
  digitalWrite(M2A, HIGH); digitalWrite(M2B, LOW);
  digitalWrite(M3A, HIGH); digitalWrite(M3B, LOW);
  digitalWrite(M4A, HIGH); digitalWrite(M4B, LOW);
}
void back() {
  digitalWrite(M1A, LOW); digitalWrite(M1B, HIGH);
  digitalWrite(M2A, LOW); digitalWrite(M2B, HIGH);
  digitalWrite(M3A, LOW); digitalWrite(M3B, HIGH);
  digitalWrite(M4A, LOW); digitalWrite(M4B, HIGH);
}
void left() {
  digitalWrite(M1A, LOW); digitalWrite(M1B, HIGH);
  digitalWrite(M2A, HIGH); digitalWrite(M2B, LOW);
}
void right() {
  digitalWrite(M1A, HIGH); digitalWrite(M1B, LOW);
  digitalWrite(M2A, LOW); digitalWrite(M2B, HIGH);
}

// =====================================================
// HTML PAGE
// =====================================================
String page() {
  float v = readBattery();
  int p = batteryPercent(v);
  String batBar = "<progress value='" + String(p) + "' max='100'></progress> "
                  + String(v,2) + " V (" + String(p) + "%)";
  String gpsStr = "NO FIX";
  if (gps.location.isValid()) {
    gpsStr = String(gps.location.lat(),6) + "," + String(gps.location.lng(),6);
  }

  String html = "<html><head><meta name='viewport' content='width=device-width, initial-scale=1'>"
  "<style>button{width:80px;height:80px;font-size:18px;margin:5px;}progress{width:80%;}</style>"
  "</head><body><h2>ESP32 Rover Control</h2>"
  "<h3>Battery:</h3>"+batBar+
  "<h3>GPS:</h3>"+gpsStr+
  "<h3>Mine Log:</h3>"+mineLog+
  "<br><br>"
  "<button onmousedown=\"fetch('/fwd')\" onmouseup=\"fetch('/stop')\">↑</button><br>"
  "<button onmousedown=\"fetch('/left')\" onmouseup=\"fetch('/stop')\">←</button>"
  "<button onmousedown=\"fetch('/back')\" onmouseup=\"fetch('/stop')\">↓</button>"
  "<button onmousedown=\"fetch('/right')\" onmouseup=\"fetch('/stop')\">→</button><br><br>"
  "<button onclick=\"fetch('/auto')\">Auto Mode</button>"
  "</body></html>";
  return html;
}

// =====================================================
void handleRoot() { server.send(200, "text/html", page()); }
void handleFwd(){forward(); server.send(200,"text/plain","FWD");}
void handleBack(){back(); server.send(200,"text/plain","BACK");}
void handleLeft(){left(); server.send(200,"text/plain","LEFT");}
void handleRight(){right(); server.send(200,"text/plain","RIGHT");}
void handleStop(){stopAll(); server.send(200,"text/plain","STOP");}
void handleAuto(){
  autoMode = !autoMode;
  server.send(200,"text/plain",autoMode?"AUTO ON":"AUTO OFF");
  stopAll();
}

// =====================================================
void setup() {
  Serial.begin(115200);
  WiFi.softAP(ssid, password);
  Serial.println(WiFi.softAPIP());

  int motors[] = {M1A,M1B,M2A,M2B,M3A,M3B,M4A,M4B,M5A,M5B,M6A,M6B,M7A,M7B};
  for (int i=0;i<14;i++) pinMode(motors[i],OUTPUT);

  pinMode(TRIG_PIN,OUTPUT);
  pinMode(ECHO_PIN,INPUT);
  pinMode(DET1,INPUT);
  pinMode(DET2,INPUT);
  pinMode(DET3,INPUT);

  bootServo.attach(SERVO_PIN);
  bootServo.write(90);

  gpsSerial.begin(GPS_BAUD, SERIAL_8N1, GPS_RX, -1);

  server.on("/", handleRoot);
  server.on("/fwd", handleFwd);
  server.on("/back", handleBack);
  server.on("/left", handleLeft);
  server.on("/right", handleRight);
  server.on("/stop", handleStop);
  server.on("/auto", handleAuto);
  server.begin();

  stopAll();
  Serial.println("Rover Ready.");
}

// =====================================================
void loop() {
  server.handleClient();

  // GPS update
  while (gpsSerial.available()) gps.encode(gpsSerial.read());

  // Auto mode behaviour
  if (autoMode) {
    long d = readDistance();
    if (d < 15) { stopAll(); delay(300); right(); delay(700); stopAll(); }
    else forward();
  }

  // Mine detection
  if (digitalRead(DET1) || digitalRead(DET2) || digitalRead(DET3)) {
    stopAll();
    String entry = "Mine Detected at ";
    if (gps.location.isValid())
      entry += String(gps.location.lat(),6)+","+String(gps.location.lng(),6);
    else entry += "NO GPS";
    entry += "<br>";
    mineLog = entry + mineLog;
    delay(1000);
  }
}
